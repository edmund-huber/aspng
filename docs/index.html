<!doctype html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>aspng: application-specific PNG</title>
        <style>
            body {
                margin: 0;
                padding: 0 15%;
            }
            /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
            canvas {
                border: 0 none;
                background-color: black;
            }
            div {
                margin: 1em 0 1em 0;
            }
            div.header {
                font-size: 140%;
                margin: 2em 0 1em 0;
            }
        </style>
    </head>
    <body>
        <div class="header">Table of contents</div>
        <div>
            <a href="#anchor-introduction">Introduction</a><br>
            <a href="#anchor-design-guide">Design guide</a><br>
            Why does this exist? and design decisions<br>
        </div>

        <div class="header" id="anchor-introduction">Introduction</div>
        <div>
            Have you ever wanted to design a CPU with Paint? Well now you can!
        </div><div>
            <u>aspng</u> ("application-specific PNG") lets you draw out
            transistor-level digital circuits using pixels, and then simulate
            (and interact with!) those circuits.
        </div><div>
            To give you an idea of what's possible, here's a full ripple adder:
            <ul>
                <li>
                    Use the switches on the left and right to change the input.
                </li><li>
                    The switch in the middle/top is for the input carry bit.
                </li><li>
                    The result (and the output carry bit) is conveyed with the
                    LEDs in the middle.
                </li>
            </ul>
        </div>
        <script type="text/javascript" src="/aspng/full_ripple_adder.js"></script>
        <canvas id="canvas1" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
        <script type="text/javascript">
            Module({
                preRun: [],
                postRun: [],
                print: function(s) { console.log("wasm: " + s); },
                printErr: function(s) { console.log("wasm: " + s); },
                canvas: (function() {
                    var canvas = document.getElementById("canvas1");
                    // TODO, should make this more robust.
                    canvas.addEventListener("webglcontextlost", function(e) {
                        console.log("WebGL context lost");
                        e.preventDefault();
                    });
                    return canvas;
                })(),
                setStatus: function(text) {},
                monitorRunDependencies: function(left) {},
                arguments: ['input.png']
            });
        </script>
        <div>
            (Note: if your browser doesn't support WASM, you will see a black
            square here.  Sorry! TODO link to later instructions on how to run
            locally)
        </div>

        <div class="header" id="anchor-design-guide">Design guide</div>
        <div>
            First, your background must be entirely black (#000000).
            <u>aspng</u> ignores black pixels.
        </div><div>
            Source pixels are white (#ffffff) and drive a high voltage. Sink
            pixels are dark gray (#303030) and drive a low voltage.<br>
            <br>
            <script type="text/javascript" src="/aspng/source_and_sink.js"></script>
            <canvas id="canvas2" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
            <script type="text/javascript">
                Module({
                    preRun: [],
                    postRun: [],
                    print: function(s) { console.log("wasm: " + s); },
                    printErr: function(s) { console.log("wasm: " + s); },
                    canvas: (function() {
                        var canvas = document.getElementById("canvas2");
                        // TODO, should make this more robust.
                        canvas.addEventListener("webglcontextlost", function(e) {
                            console.log("WebGL context lost");
                            e.preventDefault();
                        });
                        return canvas;
                    })(),
                    setStatus: function(text) {},
                    monitorRunDependencies: function(left) {},
                    arguments: ['input.png']
                });
            </script>
        </div><div>
            It is an error to connect a source to a sink directly.
        </div><div>
            Copper pixels (#f8ac59) connect components electrically.
        </div><div>
            Bridge pixels (#79443b) allow you to cross wires without connecting
            them.
        </div><div>
            Transistor pixels (#ff00f2) ...
        </div><div>
            You can create pull-ups and pull-downs using .. These "weak"
            sources and sinks drive a high or low voltage, but can be overruled
            by the presence of a conventional source or sink.
        </div><div>
            Finally, as you've seen, there are a few "template devices" such as
            input, switch, and LED. These must be reproduced exactly as shown
            or <u>aspng</u> will not recognize them.
        </div>





Why `aspng`?
------------

A digital ASIC is a careful arrangement of n- and/or p-channel MOSFETs,
pullups, pulldowns, clocks, latches, etc., implementing arbitrarily complicated
relationships between input and output pins.

![MOS 6502 designers](/readme/mos6502mask.jpg)

In the early days, all decisions about the logic and the layout of these
circuits were made by humans, and the lithography masks were drawn out by hand.
Microprocessors like the Intel 4004 and the MOS 6502 (pictured above) were
designed this way.

Today, digital ASICs are much too large and complicated to be designed by
humans. Instead, hardware description languages like Verilog or VHDL are used
to describe the behavior of the ASIC, and then very heavily researched computer
programs figure out the exact layout of physical devices to realize the design
("logic synthesis").

I'm a simple person. I romanticize those early days, with the intimate and
artisanal relationship between the designer and their circuit. `aspng` exists
so that I can capture a fraction of that feeling of satisfaction when a
carefully designed digital circuit does the right thing.

At the same time, I don't have a lifetime of experience managing power
consumption, switching delays, parasitic capacitances, capacitance delays,
leakage, and so on that true ASIC designers must have to make a functioning
circuit. I'm lazy! I just want the fun parts that make me feel smart. So on to
design decisions..

Design decisions
----------------

For the sake of keeping "ASIC design" fun (?) and feasibly simple for a
non-expert whose main motivation is seeing some blinkenlights, `aspng` greatly
simplifies all electrical properties:

* *Resistance* does not exist.
* *Capacitance* only exists in CapacitorDevices, which charge instantly and
  don't lose charge over time.
* *Inductance* does not exist.
* *Voltage* is either floating, low, or high.

Unlike very similar projects (that I know of) such as
[TICS](https://github.com/onidev/TICS), `aspng` doesn't reduce down to logical
networks of "true" or "false". To me, logical networks feel so far removed from
the reality of MOS technology and how electrical devices work, that I don't
feel compelled to write a simulator that functions at that level of
abstraction. If designing an ASIC in `aspng` is science fiction, then I view
designing a logical network as science fantasy -- interesting, but not remotely
authentic.


    </body>
</html>
